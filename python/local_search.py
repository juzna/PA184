#!/usr/bin/env python
import random
from copy import deepcopy, copy
from math import pow as power
from math import exp

from heapq import heappush, heappop, nlargest

class Frame:
    
    PENALTY_EXP = 0
    PENALTY_LIN = 20
    DELTA = 0.0005
    START_LEVEL_MULTIPLY_BEST = 2
    AVERAGE_ERRORS = 4
    
    # + raw solution: dictionary job:worker
    # + w_price, w_space, w_capacity: output of load function
    def __init__( self, raw_solution, w_price, w_space, w_capacity ):
        self.init_solution = self.solution_format( raw_solution )
        self.w_price = w_price
        self.w_space = w_space
        self.w_capacity = w_capacity
        self.wc = len(w_capacity)
    

        
    # + raw solution: dictionary job:worker
    # @return dictionary worker:list(jobs)
    def solution_format( self, raw_solution ):
        solution = {}
        for job_key in raw_solution:
            worker_id = raw_solution[job_key]
            if solution.has_key(worker_id):
                solution[worker_id].append(job_key)
            else:
                solution[worker_id] = [job_key]
        return solution
    
    # + counted solution: dictionary worker:list of jobs
    # @return dictionary job:worker
    # Inverse to solution format function
    def output_format( self, counted_solution ):
        output = {}
        for worker_id in counted_solution.keys():
            for job_id in counted_solution[worker_id]:
                output[job_id] = worker_id
        return output
        
    # level of decay
    # + current_level float
    # @return new level
    # The function is based on the article
    """
    Non-Linear Great Deluge with Learning Mechanism for Solving
    the Course Timetabling Problem
    Joe H. Obit Dario Landa-Silva Djamilah Ouelhadj Marc Sevauxy
    """
    def _decay( self, current_level ):
        level = current_level
        level = level * (
            exp(-self.DELTA * (2 + random.random()))
            )
        return level

    # ITERATIVE SEARCH
    # ++ max. number of iterations
    # ++ debug True to view intern information about progress
    def great_deluge( self, number=1600, debug = False ):
        # init solution generated by some constructive feasable h.
        solution = self.init_solution
        # best_solution = deepcopy( solution )
        # best feasable solution
        best_solution_w_e = deepcopy( solution )
        # best feasable/unfeasable price
        best_price = price = self.count( solution )
        # best only feasable price
        best_price_w_e = price
        # debug statistics
        stats1 = {
            "switch two jobs":0,
            "switch max and random jobs":0,
            "switch two workers":0,
            "rearange 2-5 workers":0,
            "rearange greedy 2-5 workers":0
            }
        if debug:
            print "Begin parameters:"
            print self.count(solution, True)
        # level of decay
        level = best_price *\
                self.START_LEVEL_MULTIPLY_BEST +\
                self.AVERAGE_ERRORS * self.PENALTY_LIN +\
                power(self.AVERAGE_ERRORS, self.PENALTY_EXP)
        # for number of interations or too low decay
        for i in range(number):
            level = self._decay( level )
            new_price, (new_solution, source) = self.select_step(
                self.available_steps( solution ) 
                )
            # if step is acceptable
            if new_price < price + level:
                price = new_price
                solution = new_solution
            # if step is optimal
            if new_price < best_price:
                # if new price doesnt have any error
                if self.count(new_solution, True)[2] == 0:
                    best_price_w_e = min(new_price, best_price_w_e)
                    best_solution_w_e = deepcopy( solution )
                if debug:
                    print self.count(new_solution, True), "  l:", round(level), source
                # best infeasable or feasable solution
                stats1[source] += 1
                best_price = min(new_price, best_price)
                # best_solution = deepcopy( solution )
            # finish condition
            if level <= max(self.PENALTY_LIN, 1):
                if debug:
                    print "level", level
                break
        return self.output_format( best_solution_w_e )

    # ITERATIVE SEARCH
    # ++ max. number of iterations
    # ++ debug True to view intern information about progress
    # ++ stop_condition_max = 10. if 10 iterations in row are worse than
    #     actual solution, break
    def run_iteration( self, number=2000, debug = False, stop_condition_max = 10 ):
        solution = self.init_solution
        price = new_price = self.count( solution )
        
        stop_condition = stop_condition_max

        stats1 = {
            "switch two jobs":0,
            "switch max and random jobs":0,
            "switch two workers":0,
            "rearange 2-5 workers":0,
            "rearange greedy 2-5 workers":0
            }
        if debug:
            print self.count(solution, True), "begin"
        min_p = price
        for i in range(number):
            if stop_condition < 0:
                break

            old_price = new_price
            new_price, (new_solution, source) = self.select_step(
                self.available_steps( solution ) 
                )
            if old_price < new_price:
                stop_condition -= 1
            else:
                stop_condition = stop_condition_max
                
            if new_price < min_p:
                price = new_price
                solution = new_solution
            if new_price < min_p:
                if debug:
                    print self.count(new_solution, True)
                stats1[source] += 1
                min_p = min(price, min_p)
        store = min_p
        
        min_p = self.count(solution)
        if debug:
            for key in stats1.keys():
                print key
                print "1:",stats1[key]
                print "2:",stats2[key]
        return self.output_format( new_solution )
            
    """
    Generate local
    """
    # + current solution
    # @return list of prices and local steps [price,solution]
    # local steps are generated randomly, because there are too many possibilities
    def available_steps( self, solution ):
        priced_solutions = []
        
        # switch two workers
        """
        for i in range(5):
            w1, w2 = self._select_n_workers( 2 )
            temp = w1
            w1 = w2
            w2 = w1
            new_solution = self._switch_all_jobs(w1, w2, solution)
            price = self.count( new_solution )
            heappush( priced_solutions, (price, (new_solution, "switch two workers") ) )
        """
        
        # switch two jobs        
        for i in range(5):
            w1, w2 = self._select_n_workers( 2 )
            j1_v = self._select_n_jobs( solution[w1], 1)
            j2_v = self._select_n_jobs( solution[w2], 1)
            # selected worker doesnt have any job
            if len(j1_v)==0 or len(j2_v)==0:
                continue
            j1 = j1_v[0]
            j2 = j2_v[0]
            new_solution = self._switch_2_jobs(w1, j1, w2, j2, solution)
            price = self.count( new_solution )
            heappush( priced_solutions, (price, (new_solution, "switch two jobs") ) )

        
        # rearange randomly x worker's jobs, x in <2,5>
        for i in range(2):
            k = random.randint(2, 5)
            w_vector = self._select_n_workers( k )
            new_solution = deepcopy( solution )

            released_jobs = []
            # release            
            for worker_id in w_vector:
                released_jobs += new_solution[worker_id]
                new_solution[worker_id] = []
                
            for job_id in released_jobs:
                new_solution[w_vector[random.randint(0, k-1)]].append(job_id)
            
            price = self.count( new_solution )
            heappush( priced_solutions, (price, (new_solution, "rearange 2-5 workers") ) )
            
        # rearange x jobs -- greedy, x in <2,5>
        for i in range(2):
            k = random.randint(2, 5)
            w_vector = self._select_n_workers( k )
            new_solution = deepcopy( solution )

            released_jobs = []
            # release            
            for worker_id in w_vector:
                released_jobs += new_solution[worker_id]
                new_solution[worker_id] = []
                
            for job_id in released_jobs:
                # find cheapest job for available workers
                min_price = 32000
                min_sel = None
                for worker_id in w_vector:
                    if self.w_price[worker_id][job_id] < min_price:
                        min_price = self.w_price[worker_id][job_id]
                        min_sel = worker_id
                new_solution[min_sel].append(job_id)
            
            price = self.count( new_solution )
            heappush( priced_solutions, (price, (new_solution, "rearange greedy 2-5 workers") ) )
            
        # move the most expensive
        most_exp_w = None
        most_exp_id = None
        most_exp_price = -1

        for worker_id in solution.keys():
            for job_id in solution[worker_id]:
                if self.w_price[worker_id][job_id]>most_exp_price:
                    most_exp_price = self.w_price[worker_id][job_id]
                    most_exp_id = job_id
                    most_exp_w = worker_id
        for i in range(5):
            w = self._select_n_workers( 1 )[0]
            while (w == most_exp_w):
                w = self._select_n_workers( 1 )[0]

            j_v = self._select_n_jobs( solution[w], 1 )
            if len(j_v)==0:
                # worker doesnt have any job
                continue
            j = j_v[0]

            new_solution = self._switch_2_jobs(most_exp_w, most_exp_id, w, j, solution)
            price = self.count( new_solution )
            heappush( priced_solutions, (price, (new_solution, "switch max and random jobs") ) )
        
        return priced_solutions
    
    # + list of (price, step)
    # @return some solution
    def select_step( self, priced_solutions ):        
        return heappop( priced_solutions )
        
    # + w1 worker 1 id
    # + w2 worker 2 id
    # + solution_old... old solution, remains intact
    # @return switched copy of solution
    def _switch_all_jobs( self, w1, w2, solution_old ):
        solution = deepcopy(solution_old)
        temp = solution[w1]
        solution[w1] = solution[w2]
        solution[w2] = temp
        return solution
    
    # + w1 worker 1 id,
    # + j1 switched job of worker 1
    # + w2 worker 2 id
    # + j2 switched job of worker 2
    # + solution_old... old solution, remains intact
    # if selected worker doesnt have any job, this fucntion is identity
    # @return switched copy of solution
    def _switch_2_jobs( self, w1, j1, w2, j2, solution_old ):
        if len(solution_old[w1])==0 or len(solution_old[w2])==0:
            return solution_old
        solution = deepcopy(solution_old)        
        solution[w1].remove(j1)
        solution[w1].append(j2)
        solution[w2].remove(j2)
        solution[w2].append(j1)        
        return solution
    
    # + w_list list of jobs available to worker
    # + number n less or equal to number of jobs
    # @return random distinct ids of jobs
    def _select_n_jobs( self, w_list, n ):        
        ws = copy(w_list)
        w_len = len(ws)
        if n > w_len:
            n = w_len
        jobs = []
        for demand in range(n):
            get = ws[random.randint(0, w_len-1)]
            while get in jobs:
                get = ws[random.randint(0, w_len-1)]
            jobs.append(get)        
        return jobs
    
    # + number n less or equal to number of workers
    # @return random distinct ids of workers
    def _select_n_workers( self, n ):
        if n > self.wc:
            n = self.wc 
        workers = []
        for demand in range(n):
            get = random.randint(0, self.wc-1)
            while get in workers:
                get = random.randint(0, self.wc-1)
            workers.append(get)
        return workers
    
    # + solution
    # ++ parts True/False, return total price or vector of cost and penalty
    # @return price of solution, tak in consideration the penalty
    def count( self, solution, parts=False ):
        cost = 0
        weight_penalty = copy(self.w_capacity)
        penalty_cost = 0
        for worker_id in solution.keys():
            for job_id in solution[worker_id]:
                cost += self.w_price[worker_id][job_id]
                weight_penalty[worker_id] -= self.w_space[worker_id][job_id]
        for item in weight_penalty:
            if item<0:
                penalty_cost += self.PENALTY_LIN + power( -1 * item, self.PENALTY_EXP)
        if parts==True:            
            return round(cost + penalty_cost), cost, round(penalty_cost)
        else:
            return float(cost + penalty_cost)
    
   
if __name__ == u"__main__":    
    from main import *
    load = load_data()    
    #from visualisation import visualize
    w_price, w_space, w_capacity = select_problem( load, 0)    
    if trivial_conditions( w_price, w_space, w_capacity ):
        #solution = constructive_greedy_heuristic_r( w_price, w_space, w_capacity, "maxmax" )
        solution = constructive_random_heuristic( w_price, w_space, w_capacity )
        print calculate_price(solution, w_price)
        f = Frame(solution, w_price, w_space, w_capacity)
        
        """
        for i in range(1,100):
            print i*10, f._decay(i*10)
        """
        result = f.great_deluge()
        print result
        #visualize( w_price, w_space, w_capacity, f.output_format( result ) )
        #f.run_iteration()
